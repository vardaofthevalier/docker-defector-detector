## Description

The `docker-defector-detector` is designed to run as a globally replicated service within a Swarm, and it's goal is to detect DNS name resolution errors from the perspective of the underlying node that the `docker-defector-detector` is running on.  

Since `docker-defector-detector` needs access to the Docker API, you must either a) volume mount the docker socket into the service containers when they are created, or 2) set the DOCKER_HOST environment variable to specify the docker URL to make API requests against.  You may also need to enable certificate verification in this case by mounting in the required certs and setting the DOCKER_CERTS_PATH and DOCKER_TLS_VERIFY variables in this case.

The log messages generated by this container are in JSON format, and have the following structure:

```
{
    "status": ("ERROR"|"INFO"),
    "source": ("service"|"environment"|"application"),
    "info": {
        "service_id": <service-id>,
        "service_name": <service-name>,
        "desired_tasks": {
            "total": <total-desired-tasks>,
            "task_to_container_id_map": {
                <service-task-id>: <service-container-id>,
                ...
            }
        },
        "stale_tasks": {
            "total": <total-stale-tasks>,
            "task_to_container_id_map": {
                <service-task-id>: <service-container-id>,
                ...
            }
        },
        "service_ip_to_hosts_map": {
            <service-ip>: [<hostname>, ...]
        },
        "service_host_to_ip_map": {
            <hostname>: [<ip>, ...]
        },
        "source_node": {
            "id": <node-id>,
            "ip": <node-ip>
        },
        "environment": <environment-name>,
        "messages": [...]
    }
}

```

The `status` field indicates whether or not this check resulted in an ERROR or is just informational (INFO).

The `source` field indicates the nature of the error:
* "application" errors are related to the docker-defector-detector application itself
* "environment" errors suggest there is a docker client connectivity issue
* "service" errors indicate that a DNS name resolution problem has been identified for a service running in the Swarm.

The `info` field was generated using the following overall stragegy:

* A determination is made about whether or not an existing service's tasks are a part of the current desired replica set or are stale.  This is done by checking to see which tasks are running (desired) vs not running (stale).
* A list of IPs to which the service's top-level hostname resolves is generated by running `net.Lookup("tasks.<service-name>")`.  The results of this call are indicated in the `service_host_to_ip_map` field. If the length of this list is longer than the number of desired tasks, then we know that there is a problem, which will be clarified by further downstream steps.
* For each of the IPs in the list generated above, a reverse hostname lookup is performed to verify that the IPs resolve to the correct service.  The results of the reverse lookup are indicated in the `service_ip_to_hosts_map` field.  For each of the hostnames derived in this step, it can be determined which ones are incorrect by asking the following questions:
	* Does this hostname contain the service name?
		* if yes:
			* does it contain a valid task id?  If not, then we conclude that the IP address resolves to a stale task, which is an error condition.
		* if no:
			* does this hostname match the "service replica" regex?
				* if yes: we conclude that the IP resolves to the wrong service entirely, which is an error condition
				* if no:
					* does this hostname match the "container id" regex? 
						* if no: then we conclude that the IP address resolves to a stale container, which is an error condition.

The solution to the detected problems involves correcting the IPVS configuration for the service on the Swarm node reported in the `source_node` field.

It's recommended that you log this service's container's logs to syslog for downstream consumption by a monitoring/alerting pipeline in order to effectively and quickly respond to the errors detected.


## Building
To build the container, simply run `docker build -t <my-repo>/docker-defector-detector .` from the root of this repository.  

A pre-built version of the container can also be found on [Dockerhub](https://hub.docker.com/r/onelouder/docker-defector-detector/).


## Usage

In general, the service depends on the following environment variables:

* INTERVAL: the time interval (an integer value) on which to run checks on services in the Swarm (in seconds)
* ENVIRONMENT: an arbitrary string to indicate the lifecycle environment from which data is being collected (assumes a one-to-one match with the current Swarm)
* CONTAINER_NAME: the name of the docker-defector-detector container within the service (used for self-introspection)
* SERVICE_NAME: the name of the docker-defector-detector service name within the Swarm (also used for self-introspection)

Example: deploy using the host's docker socket:

```docker service create \
	--name docker-defector-detector \
	--mode global \
	--log-driver syslog \
	--env INTERVAL=60 \
	--env ENVIRONMENT=qa \
	--env CONTAINER_NAME=onelouder/docker-defector-detector \
	--env SERVICE_NAME=docker-defector-detector \
	--mount type=bind,source=/var/run/docker.sock,destination=/var/run/docker.sock \
	onelouder/docker-defector-detector
```

Example: deploy using a (secure) TCP connection:

```docker service create \
	--name docker-defector-detector \
	--mode global \
	--log-driver syslog \
	--env INTERVAL=60 \
	--env ENVIRONMENT=qa \
	--env CONTAINER_NAME=onelouder/docker-defector-detector \
	--env SERVICE_NAME=docker-defector-detector \
	--env DOCKER_HOST=<DOCKER_HOST_URL> \
	--env DOCKER_CERTS_PATH=<CONTAINER_PATH_TO_CERTS_DIRECTORY> \
	--env DOCKER_TLS_VERIFY=true
	--mount type=bind,source=<HOST_PATH_TO_CERTS_DIRECTORY>,destination=<CONTAINER_PATH_TO_CERTS_DIRECTORY> \
	onelouder/docker-defector-detector
```
